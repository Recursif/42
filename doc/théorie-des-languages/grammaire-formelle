
# Grammaire:

c'est l'étude systématique des éléments constitutifs
d'une langue.



# Grammaire Formelle:

Une grammaire formelle permet de definir une syntaxe
et donc un language formel.

Une grammaire formelle est utilisé en programmation compilation
analyse syntaxique, en théorie de la calculabilité
et dans le traitement des languages naturelles
(morphologie de syntaxe).



## Language

Un language est un ensemble de mots, qui sont
simplement des séquences de symboles choisis dans
un ensemble appelé alphabet.



## Théorie

Formellement, si A est un ensemble, on note A* le monoïde libre sur A.

C'est-à-dire l'ensemble des suites finies d'éléments de A,
muni de l'opération de concaténation de deux mots.

Un langage sur l'alphabet A est par définition un sous-ensemble
de A*.

Par exemple :

A1 = { a, b, c, d, e } est un alphabet contenant 5 symboles, traditionnellement appelés lettres dans ce cas précis ;
A2 = { 2, 5, @, $, & } est un autre alphabet contenant 5 symboles ;
A3 = { Dét, Adj, Verbe, Nom, Coord, Prép } est un alphabet de 6 symboles pouvant décrire, par exemple, la structure syntaxique d'une phrase dans une langue naturelle.



## Lexème

Le lexeme est le morphème lexical d'un lemme, c'est à dire
une unité de sens et de son qui n'est pas fonctionnelle ou
derivationnelle.

lexème = radical



## Grammaires Formelles Def Mathématique

Une grammaire formelle est constituée de quatre objets:
- un ensemble fini de symboles, appelé symboles terminaux (écrit en minuscule)

- un ensemble fini de symboles, appelé symboles non-terminaux (écrit en majuscule)

- un élément de l'ensemble des non-terminaux, appelé axiome, noté conventionnellement S

- un ensembles de règles de production,
qui sont des paires formées d'un non-terminal et d'une suite de terminaux
Ex: A -> ABa

Cf symboles-terminaux-non-terminaux


Un language formel défini (ou engendré) par une grammaire particulière
est l'ensemble des chaines ou mots de caractères terminaux produites par la grammaire.

Les non terminaux n'étant pas constuits entièrement de terminaux ne peuvent pas
apparaitre comme lexèmes appartenant au language.

Dans un contexte d'analyse syntaxique, étant opposé à la théorie
des langages de programmation et des compilateurs, les termes symboles terminal et jeton
sont souvent considérés synonymes.

Appliquer une règle de production consiste à remplacer
dans un mot  une occurence du membre de gauche de cette règle par son membre de droite.
l'application successive de règles de productions s'appelle une dérivation.
Ex A -> Abn -> Abnbn


Le language défini par une grammaire est l'ensemble dse mots formés uniquement
de symboles terminaux qui peuvent être atteints par dérivation à partir de l'axiome.

Ainsi, la grammaire définie par les terminaux {a, b}, le non-terminal S,
l'axiome S et les deux règles de production suivantes :

  S -> aSb
  S -> e (e = l'ensemble vide)

représente le langage des mots de la forme a^n*b^n
{ e, ab, aabb, aaabbb, ...}



## Hierarchie de Chomsky:

4 niveaux du plus restrictif au plus large:

- languages de type 3, languages rationnels:
ce sont les languages définis par une grammaire linéaire à gauche
(c'est-à-dire une grammaire dont chaque membre droit de règle commence par un non-terminal)
et une grammaire linéaire à droite
(c'est-à-dire une grammaire dont chaque membre droit de règle finit par un non-terminal)
ou une expression rationnelle ( expression regulière)

Ces langages sont reconnus par un automate fini.

- langages de type 2, langages algébriques:
ce sont les langages définis par une grammaire algébriques,
langages reconnaissable par un automate à pile non déterministe.

La plupart des langages de programmation, sans être à proprement parler
des langages algébriques, en sont assez proches pour que les techniques d'analyse
des langages s'y adaptent.

- langages de type 1, langage contextuels:
ce sont les langages définis par une grammaire contextuelle,
ou encore les langages reconnaissable par une machine de turing
non deterministe à ruban de longueur borné
par un multiple fixé de longueur du mot d'entrée,
appelé automate linéairement borné.

- langages de type 0, langages récursivement énumérables.
Cet ensemble inclut tous les langages définis par une gramaire formelle.
C'est aussi l'ensemble des langages acceptables par une machine de turing.


Il existe aussi des classes intermédiares:
 - Les langages algébriques déterministes, reconnaissables par
 un automate à pile déteriniste;
 la famille des langages algébriques inambigus.

 - Les langages récursif, cad reconnaissables par une Machine de turing
 (celle ci doit refuser les mots qui ne sont pas du langage).



## Analyse

Un analyseur pour un langage formel est un programme informatique qui décide si un mot
donné en entrée appartient ou non au langage, et éventuellement en construire une dérivation.

Les interpreteur et les compilateur comprennent presque toujours une phrase d'analyse lexical,
qui consiste à reconnaitre des langages de types 3,
suivie d'une phase d'analyse syntaxique qui est
une analyse de langage de type 2.
L'analyse lexical porte sur une suite de caractères et produit une suite de lexèmes,
qui servent à leur tour d'élément d'alphabet lors de l'analyse syntaxique.

Des outils comme lex et yacc facilitent l'écriture, respectivement,
d'analyseurs lexicaux et syntaxiques,
en produisant automatiquement des portions de programmes
à partir d'une spécification de ce langage.

Les constructeur d'analyseurs syntaxiques utilisent
souvent yune variante de la forme de Backus-Naur,
qui est une notation pour les grammaires hors-contexte.

Tandis que les constructeurs d'analyseurs lexicaux
emploient le formalisme moins lourd des expressions rationnelles.



## Expression arithmériques:

exp ::= exp + exp
      | exp × exp
      | (exp)
      | num
num ::= chiffre num
      | chiffre
chiffre ::=  0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9


les non-terminaux sont les exp, num et chiffre
les terminaux sont +, x, (, ), les chiffres.
l'axiome est exp.

La dérivation suivante est un exemple d'utilisation de cette grammaire.
 exp → exp × exp → num × exp → chiffre × exp → 3 × exp → 3 × num → 3 × chiffre num →3 × 1 num → 3 × 1 chiffre → 3 × 18

- les parenthèses implique que ce languages est de classe 2;
- permet de reconnaitre les expressions arithmétiques,
sans rendre compte de la priorité des opérateurs.
Cette grammaire ne distingue pas (1 + 2) x 4 de 1 + (2 x 4)



## Langage de programmation:

Pascal: fact(10)
begin
int a;
int b;
a:=10;
b:=1;
while(a>1) do
  b:=a*b;
  a:=a-1;
od;
print b;
end

grammaire correspondante:
program ::= ''begin'' listinstr ''end''
 listinstr ::= instr listinstr
             | instr
 instr ::= ''int'' id '';''
         | id '':='' expr '';''
         | ''print'' expr '';''
         | ''while'' ''('' cond '')'' ''do'' listinstr ''od'' '';''
 expr ::= expr ''-'' expr1
        | expr1
 expr1 ::= expr1 ''*'' expr2
         | expr2
 expr2 ::= id
         | num
         | ''('' expr '')''
 cond ::= expr condsymb expr
 condsymb ::= ''>'' | ''<'' | ''>='' | ''<='' | ''!='' | ''=''


 terminaux : id / num / begin / print / while / () / do / od / ; et les symboles de comparaison

 grammaire de type 2: on ne peut pas verifier que
 toutes les variable ont été déclarées (pour cela grammaire de type 1).
  Il faudrait aussi ajouter des règles pour num (comme plus haut) et pour id.



## Logique proportionnelle

L-système ou système de Lindemayer:
  grammaire formelle générative ayant vocation à décrire
  les developpement du vivant : champignons plantes ...


Equivalence forte entre grammaire:
- elles reconnaissent éxactement le même language
- elles utilisent exactement les mêmes dérivations pour analyser une même phrase.

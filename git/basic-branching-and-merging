
# Basic Branching and Merging

Let's go through a simple example of branching
and merging with a workflow that you miht use in the
real world. You'll follow these steps:

1- Do some work on a website

2- Create a branch for a new story you're working on.

3- Do some work in that branch.

At this stage, you'll receive a call that another issue is critical
and you need a hotfix.
You'll do the following:

1- Switch to your production branch.

2- Create a branch to add the hotfix.

3- After it's tested, merge the hotfix branch, and push to production.

4- Switch back to your original story and continue working.


## Basic branching

You working on master.

You've decided that you're going to work on issue #53


$ git checkout -b iss53
Switched to a new branch "iss53"

or :

$ git branch iss53
$ git checkout iss53

You work and do some commit.

$ vim index.html
$ git commit -a -m 'added a new footer [issue 53]'

For now, let’s assume you’ve committed all your changes,
so you can switch back to your master branch:

$ git checkout master
Switched to branch 'master'

Next, you have a hotfix to make. Let’s create a hotfix branch on which to work until it’s completed:

$ git checkout -b hotfix
Switched to a new branch 'hotfix'
$ vim index.html
$ git commit -a -m 'fixed the broken email address'
[hotfix 1fb7853] fixed the broken email address
 1 file changed, 2 insertions(+)



 You can run tests, make sure the hotfix is what you want,
 and finally merger the hotfix branch back into your master
 branch to deploy to production.

 You do this with the git merge command:

 $ git checkout master
 $ git merge hotfix
 Updating f42c576..3a0874c
 Fast-forward
  index.html | 2 ++
  1 file changed, 2 insertions(+)

You’ll notice the phrase “fast-forward” in that merge.

 Git simply moves the pointer forward.

To phrase an another way, when you try to merge one commit with a commit
that can be reached by following the first commit's history,
Git simplified thingss by moving the pointer forward because there is no divergent
work to merge together - this is called a "fast-forward".

Your change is now in the snapshot of the commit pointer to by the master branch, and you can
deploy the fix.

After your fix is deployed, you're ready to switch back to the work you were doing before
you were interrupted. However, first you'll delete the hotfix branch,
because you no longer need it

$ git branch -d hotfix
Deleted branch hotfix (3a0874c).

Now you can switch back to your work-in-progress branch on issue #53 and continue
working on it.

$ git checkout iss53
Switched to branch "iss53"
$ vim index.html
$ git commit -a -m 'finished the new footer [issue 53]'
[iss53 ad82d7a] finished the new footer [issue 53]
1 file changed, 1 insertion(+)


It's worth nothing that the work you did in your hotfix branch is not contained in the files in your iss53 branch.

If you need to pull it in, you can merge your master branch into your iss53 branch by running git merge master,
or you can wait to integrate those changes until you decide to pull the iss53 branch back into master later.

## Basic merging

Suppose you've decided that your issue #53 work is complete and ready to be merge into your master branch.

In order to do that, you 'll merge your iss53 branch into master.

All you have to do is check out the branch you wish to merge into and then run the git merge command:

$ git checkout master
Switched to branch 'master'
$ git merge iss53
Merge made by the 'recursive' strategy.
index.html |  1 +
1 file changed, 1 insertion(+)

Instead of just moving the branch pointer forward,
Git creates a new snapshot that results from this three-way merge
and automatically creates a new commit that points to it.
This is referred to as a merge commit, and is special in that it has more than one parent.


It's worth pointing out that Git determines the Best common ancestor to use for its merge base;

this is different than older tools like CVS or Subersion, wher the developer doing the
merge had to figure out the best merge base for themselves.
This makes merging a heck of a lot easier in Git than in these other systems.

Now that your work is merged in, you have no further need for the iss53 branch. You can close the ticket
in your ticket-tracking system, and delete the branch:

$ git branch -d iss53


## Basic Merge Conflicts

Occasionally, this process doesn't go smoothly.
If you changed the same part of the same file diffently in
the two branches you're merging together, Git won't be able
to merge them cleanly.

$ git merge iss53
Auto-merging index.html
CONFLICT (content): Merge conflict in index.html
Automatic merge failed; fix conflicts and then commit the result.

Git hasn't automatically created a new merge commit.
It has paused the process while you resolve the conflict.
If you want to see which files are unmerged at any point after a merge conflict,
you can run git status:

$ git status
On branch master
You have unmerged paths.
  (fix conflicts and run "git commit")

Unmerged paths:
  (use "git add <file>..." to mark resolution)

    both modified:      index.html

no changes added to commit (use "git add" and/or "git commit -a")


Anything that has merge conflicts and hasn't been resolved is listed as
unmerger. Git adds standard conflict-resolution markers to the files that have conflicts,
so you can open them manually and resolve those conflicts.

Your file contains a section that looks somthing like this:

<<<<<<< HEAD:index.html
<div id="footer">contact : email.support@github.com</div>
=======
<div id="footer">
 please contact us at support@github.com
</div>
>>>>>>> iss53:index.html


This means the version in HEAD is the top part of that block (top of =======),
while the version iss53 branch looks like everything in the bottom part.

In order to resolve the conflict, you have to either choose one side or the other.

After you’ve resolved each of these sections in each conflicted file,
run git add on each file to mark it as resolved.
Staging the file marks it as resolved in Git.

If you want to use a graphical tool resolve these issues, you can run
git mertools, which fires up an appropriate visual merge tool walks you
through the conflicts:

$ git mergetool

This message is displayed because 'merge.tool' is not configured.
See 'git mergetool --tool-help' or 'git help config' for more details.
'git mergetool' will now attempt to use one of the following tools:
opendiff kdiff3 tkdiff xxdiff meld tortoisemerge gvimdiff diffuse diffmerge ecmerge p4merge araxis bc3 codecompare vimdiff emerge
Merging:
index.html

Normal merge conflict for 'index.html':
  {local}: modified file
  {remote}: modified file
Hit return to start merge resolution tool (opendiff):


After you exit the merge tool, Git asks you if the merge was successful.

If you tell the script that it was, it stages the files to mark it as resolved for you.

You can run git status again to verify that all conflicts have been resolved:

$ git status
All conflicts fixed but you are still merging.
  (use "git commit" to conclude merge)

Changes to be committed:

    modified:   index.html

If you are happy with that, and you verify that everything that had conflicts has been staged,
you can type git commit.

Merge branch 'iss53'

Conflicts:
    index.html
#
# It looks like you may be committing a merge.
# If this is not correct, please remove the file
#	.git/MERGE_HEAD
# and try again.


# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# All conflicts fixed but you are still merging.
#
# Changes to be committed:
#	modified:   index.html
#

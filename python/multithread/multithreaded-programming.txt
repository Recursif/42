

# Multithreaded Programming 

Runnings several threads is similar to running 
several different programs concurrently, but with 
the following benefits 

Multiple threads within a process share the same 
data space with the main thread and can therefore 
share information or communicate with each 
other more easily than if they were separate 
processes.

Threads sometimes called light-wieght processes and 
they do not require much memory overhead; 
they are cheaper than processes.

A thread has a beginning, an execution sequence, and 
a conclusion.

It has an instruction pointer that keeps track 
of where within its context it is currently running.

It can be pre-empted (interrupted)

It can temporaly be put on hold (also known as sleeping)
while the other threads are running - this is called yielding.


## Starting a New Thread 

To spawn another thread, you need to call following 
method:

import thread 
import time 

thread.start_new_thread( function, args[, kwargs] )

This method call enables a fast and efficient way to create 
new threads in both Linux and Windows.

The method call returns immediately 
and the child thread starts and calls function 
with the passed list of args. 
When function returns, the thread terminates.

Here, args is a tuple of arguments; use an empty 
tuple to call function without passing any arguments.

kwargs is an optional dictionary of keyword arguments.

There are two different kind of threads −

kernel thread
user thread

Kernel Threads are a part of the operating system, while the User-space threads are not implemented in the kernel.


There are two modules which support the usage of threads in Python3 −

_thread
threading

Ex:

#!/usr/bin/python3

import _thread
import time

# Define a function for the thread
def print_time( threadName, delay):
   count = 0
   while count < 5:
      time.sleep(delay)
      count += 1
      print ("%s: %s" % ( threadName, time.ctime(time.time()) ))

# Create two threads as follows
try:
   _thread.start_new_thread( print_time, ("Thread-1", 2, ) )
   _thread.start_new_thread( print_time, ("Thread-2", 4, ) )
except:
   print ("Error: unable to start thread")

while 1:
   pass


## The threading Module 

The threading module exposes all the methods 
of the thread module and provides some aditional 
methods 

threading.activeCount() - Returns the number of thread 
objects that are active.

threading.currentThread() - Returns the number 
of thread objects in the caller's thread control.

threading.eneumerate() - Returns a list of all thread 
objects that are currently active.


In addition to the methods, threading module 
has the Thread class that implements threading.

The methods provided by Thread class are as follows - 

-run() - the run() method is the entry point 
for a thread.

-start() - The start() method starts a thread 
by calling the run method.

-join([time]) - The join() waits for threads to terminate.

-isAlive() - The isAlive() method checks whether 
a thread is still executing.

-getName() - The getName() method returns the name 
of thread.

-setName() - The setName() method sets the name of a thread.


## Creating Thread Using Threading Module 

To implement a new thread using the threading module,
you have to do the following :

Define a new subclass of the Thread class.

Override the __init__(self [,args]) method to 
add additional arguments.

Then, override the run(self [,args]) method to implement 
what the thread should do when started.

Once you have created the new Thread subclass, you can 
create an instance of it and then start a new 
thread by invoking the start(), which in turn calls the run() method.

#!/usr/bin/python3

import threading
import time

exitFlag = 0

class myThread (threading.Thread):
    def __init__(self, threadID, name, counter):
        threading.Thread.__init__(self)
        self.threadID ) threadID
        self.name = name
        self.counter = counter 
    def run(self):
        print ("Starting " + self.name)
        print_time(self.name, self.counter, 5)
        print ("Existing " + self.name)

def print_time(threadName, delay, counter):
    while counter:
        if exitFlag:
            threadName.exit()
        time.sleep(delay)
        print ("%s: %s" % (threadName, time.ctime(time.time())))
        counter -= 1

# Create new threads 
thread1 = myThread(1, "Thread-1", 1)
thread2 = myThread(2, "Thread-2", 2)

# Start new Threads
thread1.start()
thread2.start()
thread1.join()
thread2.join()

print ("Existing Main Thread")

